<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>streamscribe</title>
<style>
  :root {
    --bg: #0d1117; --surface: #161b22; --border: #30363d;
    --text: #e6edf3; --muted: #8b949e; --accent: #58a6ff;
    --green: #3fb950; --red: #f85149; --yellow: #d29922;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
    background: var(--bg); color: var(--text);
    height: 100vh; display: flex; flex-direction: column;
    overflow: hidden;
  }

  /* Top bar */
  .topbar {
    padding: 12px 20px; display: flex; align-items: center;
    justify-content: space-between; border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  .topbar h1 { font-size: 16px; font-weight: 600; }
  .topbar h1 span { color: var(--muted); font-weight: 400; }
  .topbar .right { display: flex; align-items: center; gap: 12px; }
  .topbar .stats { color: var(--muted); font-size: 12px; }
  .topbar .pl-btn {
    background: none; border: 1px solid var(--border); color: var(--muted);
    padding: 3px 8px; border-radius: 5px; font-size: 11px; cursor: pointer;
  }
  .topbar .pl-btn:hover { color: var(--text); border-color: var(--muted); }
  .topbar .pl-btn.flash { color: var(--green); border-color: var(--green); }

  /* Add form */
  .add-form {
    display: flex; gap: 8px; padding: 12px 20px;
    border-bottom: 1px solid var(--border); flex-shrink: 0;
    flex-wrap: wrap;
  }
  .add-form input, .add-form select, .add-form button {
    padding: 6px 10px; border-radius: 6px; border: 1px solid var(--border);
    background: var(--surface); color: var(--text); font-size: 13px;
  }
  .add-form input { flex: 1; min-width: 180px; }
  .add-form input::placeholder { color: var(--muted); }
  .add-form input[name="name"] { max-width: 140px; flex: 0; min-width: 100px; }
  .add-form select { min-width: 80px; }
  .add-form button {
    background: var(--accent); color: #fff; border: none;
    cursor: pointer; font-weight: 600; white-space: nowrap;
  }
  .add-form button:hover { opacity: 0.85; }
  .add-form button:disabled { opacity: 0.6; cursor: not-allowed; }
  .error { color: var(--red); font-size: 13px; padding: 0 20px 8px; }

  /* Stream grid */
  .grid {
    flex: 1; display: grid; gap: 0; overflow: hidden;
    grid-template-columns: 1fr;
  }
  .grid.cols-2 { grid-template-columns: 1fr 1fr; grid-auto-rows: 1fr; }
  .grid.cols-3 { grid-template-columns: 1fr 1fr 1fr; grid-auto-rows: 1fr; }
  .grid.cols-4 { grid-template-columns: 1fr 1fr; grid-auto-rows: 1fr; }

  /* Stream tile */
  .tile {
    display: flex; flex-direction: column;
    border-right: 1px solid var(--border);
    border-bottom: 1px solid var(--border);
    overflow: hidden; position: relative;
  }
  .tile-header {
    padding: 8px 12px; display: flex; align-items: center;
    justify-content: space-between; border-bottom: 1px solid var(--border);
    background: var(--surface); flex-shrink: 0; gap: 8px;
  }
  .tile-title {
    font-weight: 600; font-size: 13px;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    min-width: 0;
  }
  .tile-meta {
    display: flex; gap: 8px; align-items: center; flex-shrink: 0;
    color: var(--muted); font-size: 11px;
  }
  .tile-meta .badge {
    padding: 1px 5px; border-radius: 3px; font-size: 10px;
    font-weight: 600; letter-spacing: 0.5px; color: #fff;
  }
  .tile-meta .badge-live {
    background: var(--red); animation: pulse 2s infinite;
  }
  .tile-meta .badge-loading {
    background: var(--yellow); color: #000; animation: pulse 1.5s infinite;
  }
  .tile-meta .badge-error {
    background: var(--red); opacity: 0.7;
  }
  .tile-meta .badge-done {
    background: var(--muted);
  }
  @keyframes pulse {
    0%, 100% { opacity: 1; } 50% { opacity: 0.6; }
  }
  .tile-meta .seg {
    background: var(--border); padding: 1px 5px; border-radius: 3px;
  }
  .btn-vid {
    background: none; border: 1px solid var(--border); color: var(--muted);
    cursor: pointer; font-size: 10px; line-height: 1; padding: 1px 4px;
    border-radius: 3px; font-family: inherit;
  }
  .btn-vid:hover { color: var(--text); border-color: var(--muted); }
  .btn-x {
    background: none; border: none; color: var(--muted);
    cursor: pointer; font-size: 16px; line-height: 1; padding: 0 2px;
  }
  .btn-x:hover { color: var(--red); }

  /* Transcript body */
  .tile-body {
    flex: 1; overflow-y: auto; padding: 8px 12px;
    font-size: 13px; line-height: 1.65;
    scroll-behavior: smooth;
  }
  .tile-body:empty::after {
    content: "Waiting for audio...";
    color: var(--muted); font-style: italic;
  }
  .tile-body.video-mode {
    padding: 0; overflow: hidden;
  }
  .tile-body.video-mode iframe {
    width: 100%; height: 100%; border: none;
  }
  .seg { padding: 1px 0; }
  .seg-time {
    color: var(--muted); font-size: 11px; font-family: monospace;
    margin-right: 6px; user-select: none; cursor: pointer;
  }
  .seg-time:hover { color: var(--accent); }
  .seg-speaker {
    font-size: 11px; font-weight: 600; margin-right: 5px;
  }
  .seg-text { }

  /* Speaker colors — cycle through a palette */
  .spk-1 { color: #58a6ff; }
  .spk-2 { color: #3fb950; }
  .spk-3 { color: #d29922; }
  .spk-4 { color: #f778ba; }
  .spk-5 { color: #bc8cff; }
  .spk-6 { color: #39d2c0; }

  /* Status messages in tile body */
  .status-msg {
    color: var(--muted); font-style: italic;
    display: flex; align-items: center; justify-content: center;
    height: 100%; gap: 8px;
  }
  .status-msg.error { color: var(--red); }

  /* Empty state */
  .empty-state {
    display: flex; align-items: center; justify-content: center;
    flex: 1; color: var(--muted); font-size: 14px;
  }
</style>
</head>
<body>

<div class="topbar">
  <h1>streamscribe <span>/ live</span></h1>
  <div class="right">
    <div class="stats" id="stats"></div>
    <button class="pl-btn" onclick="copyPlaylist(this)" title="Copy stream list to clipboard">Copy</button>
    <button class="pl-btn" onclick="pastePlaylist(this)" title="Paste stream list from clipboard">Paste</button>
  </div>
</div>

<form class="add-form" onsubmit="return addStream(event)">
  <input name="url" placeholder="YouTube URL, Jitsi room, HLS stream..." required>
  <input name="name" placeholder="Label">
  <select name="type">
    <option value="">auto</option>
    <option value="jitsi">jitsi</option>
    <option value="url">url</option>
    <option value="browser">browser</option>
    <option value="direct">direct</option>
  </select>
  <button type="submit">+ Add</button>
</form>
<div id="error" class="error"></div>

<div id="grid" class="grid">
  <div class="empty-state" id="empty">No active streams. Add one above.</div>
</div>

<script>
const API = '';
const TAIL = 50;
let streams = {};
const videoMode = new Set();

async function poll() {
  try {
    const res = await fetch(`${API}/streams`);
    const list = await res.json();

    // Update stats
    const total = list.reduce((n, s) => n + s.segments, 0);
    document.getElementById('stats').textContent =
      `${list.length} stream${list.length !== 1 ? 's' : ''} \u00b7 ${total} segments`;

    // Detect added/removed
    const names = new Set(list.map(s => s.name));
    const cur = new Set(Object.keys(streams));
    let changed = names.size !== cur.size;
    for (const n of names) if (!cur.has(n)) changed = true;
    for (const n of cur) if (!names.has(n)) { delete streams[n]; changed = true; }
    for (const s of list) streams[s.name] = s;

    if (changed) rebuildGrid(list);

    // Fetch transcripts in parallel
    await Promise.all(list.map(s => fetchTail(s.name)));
  } catch (e) {
    console.error('poll error', e);
  }
}

function rebuildGrid(list) {
  const grid = document.getElementById('grid');
  const empty = document.getElementById('empty');

  if (list.length === 0) {
    grid.innerHTML = '';
    grid.className = 'grid';
    grid.appendChild(empty);
    empty.style.display = '';
    return;
  }
  empty.style.display = 'none';

  // Grid layout
  grid.className = 'grid' + (list.length >= 4 ? ' cols-4' :
    list.length === 3 ? ' cols-3' : list.length === 2 ? ' cols-2' : '');

  grid.innerHTML = list.map(s => {
    const [bc, bt] = badgeFor(s.status);
    const embed = toEmbedUrl(s.url);
    const inVid = videoMode.has(s.name);
    const vidBtn = embed
      ? `<button class="btn-vid" id="vid-${esc(s.name)}" onclick="toggleVideo('${esc(s.name)}')">${inVid ? 'Aa' : '\u25b6'}</button>`
      : '';
    return `
    <div class="tile" id="tile-${esc(s.name)}">
      <div class="tile-header">
        <span class="tile-title" title="${esc(s.url)}">${esc(s.name)}</span>
        <div class="tile-meta">
          <span class="badge ${bc}" id="badge-${esc(s.name)}">${bt}</span>
          <span class="seg" id="meta-${esc(s.name)}">${s.segments} seg</span>
          <span id="uptime-${esc(s.name)}">${formatUptime(s.uptime_s)}</span>
          ${vidBtn}
          <button class="btn-x" onclick="removeStream('${esc(s.name)}')" title="Remove">\u00d7</button>
        </div>
      </div>
      <div class="tile-body${inVid ? ' video-mode' : ''}" id="body-${esc(s.name)}">${
        inVid ? `<iframe src="${embed}" allow="autoplay;encrypted-media" allowfullscreen></iframe>` : ''
      }</div>
    </div>`;
  }).join('');
}

async function fetchTail(name) {
  try {
    const res = await fetch(`${API}/streams/${encodeURIComponent(name)}`);
    if (!res.ok) return;
    const data = await res.json();

    // Update meta
    const metaEl = document.getElementById(`meta-${name}`);
    if (metaEl) metaEl.textContent = `${data.segments} seg`;
    const upEl = document.getElementById(`uptime-${name}`);
    if (upEl) upEl.textContent = formatUptime(data.uptime_s);

    // Update status badge
    const badgeEl = document.getElementById(`badge-${name}`);
    if (badgeEl) {
      const [bc, bt] = badgeFor(data.status);
      badgeEl.className = `badge ${bc}`;
      badgeEl.textContent = bt;
    }

    const body = document.getElementById(`body-${name}`);
    if (!body) return;
    if (videoMode.has(name)) return;

    // Show status messages for non-active streams
    if (data.status === 'error') {
      body.innerHTML = `<div class="status-msg error">${esc(data.error || 'Stream failed')}</div>`;
      return;
    }
    if (data.status === 'starting' && data.transcript.length === 0) {
      body.innerHTML = '<div class="status-msg">Loading stream...</div>';
      return;
    }

    const wasAtBottom = body.scrollTop + body.clientHeight >= body.scrollHeight - 30;
    const tail = data.transcript.slice(-TAIL);
    const ep = data.epoch_start || null;

    body.innerHTML = tail.map(seg => {
      const spkClass = seg.speaker ? `spk-${speakerNum(seg.speaker)}` : '';
      return `<div class="seg"><span class="seg-time" data-t="${seg.time}">${formatTime(seg.time, ep)}</span>${
        seg.speaker ? `<span class="seg-speaker ${spkClass}">${esc(seg.speaker)}</span>` : ''
      }<span class="seg-text">${esc(seg.text)}</span></div>`;
    }).join('');

    if (wasAtBottom) body.scrollTop = body.scrollHeight;
  } catch (e) {}
}

function speakerNum(s) {
  const m = s.match(/\d+/);
  return m ? ((parseInt(m[0]) - 1) % 6) + 1 : 1;
}

async function addStream(e) {
  e.preventDefault();
  const form = e.target;
  const btn = form.querySelector('button');
  const body = { url: form.url.value };
  if (form.name.value) body.name = form.name.value;
  if (form.type.value) body.type = form.type.value;

  const errEl = document.getElementById('error');
  errEl.textContent = '';
  btn.disabled = true;
  btn.textContent = 'Adding...';

  try {
    const res = await fetch(`${API}/streams`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify(body),
    });
    const data = await res.json();
    if (!res.ok) {
      errEl.textContent = data.error || 'Failed to add stream';
      return false;
    }
    form.reset();
    poll();
  } catch (e) {
    errEl.textContent = 'Request failed';
  } finally {
    btn.disabled = false;
    btn.textContent = '+ Add';
  }
  return false;
}

async function removeStream(name) {
  await fetch(`${API}/streams/${encodeURIComponent(name)}`, {method: 'DELETE'});
  delete streams[name];
  poll();
}

function formatTime(s, epochStart) {
  if (epochStart) {
    const d = new Date((epochStart + s) * 1000);
    return d.toLocaleTimeString([], {hour: 'numeric', minute: '2-digit', second: '2-digit'});
  }
  const h = Math.floor(s / 3600);
  const m = Math.floor((s % 3600) / 60);
  const sec = Math.floor(s % 60);
  if (h > 0) return `${pad(h)}:${pad(m)}:${pad(sec)}`;
  return `${pad(m)}:${pad(sec)}`;
}

function formatUptime(s) {
  if (s < 60) return `${s}s`;
  if (s < 3600) return `${Math.floor(s/60)}m`;
  return `${Math.floor(s/3600)}h ${Math.floor((s%3600)/60)}m`;
}

function badgeFor(status) {
  if (status === 'starting') return ['badge-loading', 'LOADING'];
  if (status === 'error') return ['badge-error', 'ERROR'];
  if (status === 'stopped') return ['badge-done', 'DONE'];
  return ['badge-live', 'LIVE'];
}

function pad(n) { return String(n).padStart(2, '0'); }
function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }

function toEmbedUrl(url, startSec) {
  try {
    const u = new URL(url);
    if (u.hostname.includes('youtube.com') || u.hostname.includes('youtu.be')) {
      let vid = u.searchParams.get('v');
      if (!vid) vid = u.pathname.replace(/^\//, '').split('/').pop();
      if (vid) {
        let src = `https://www.youtube.com/embed/${vid}?autoplay=1&mute=1`;
        if (startSec != null) src += `&start=${Math.floor(startSec)}`;
        return src;
      }
    }
  } catch (e) {}
  return null;
}

function seekVideo(name, seconds) {
  const s = streams[name];
  if (!s) return;

  // Convert our relative timestamp to the YouTube video's timeline
  let seekSec = seconds;
  if (s.epoch_start && s.release_timestamp) {
    seekSec = (s.epoch_start + seconds) - s.release_timestamp;
    if (seekSec < 0) seekSec = 0;
  }

  // 15 second video pre-roll so you see context before the transcript line
  const startAt = Math.max(0, seekSec - 15);
  const embed = toEmbedUrl(s.url, startAt);
  if (!embed) return;

  const body = document.getElementById(`body-${name}`);
  const btn = document.getElementById(`vid-${name}`);
  if (!body) return;

  videoMode.add(name);
  body.className = 'tile-body video-mode';
  body.innerHTML = `<iframe src="${embed}" allow="autoplay;encrypted-media" allowfullscreen></iframe>`;
  if (btn) btn.textContent = 'Aa';
}

function toggleVideo(name) {
  const body = document.getElementById(`body-${name}`);
  const btn = document.getElementById(`vid-${name}`);
  const s = streams[name];
  if (!body || !s) return;

  if (videoMode.has(name)) {
    videoMode.delete(name);
    body.className = 'tile-body';
    body.innerHTML = '';
    if (btn) btn.textContent = '\u25b6';
  } else {
    const embed = toEmbedUrl(s.url);
    if (!embed) return;
    videoMode.add(name);
    body.className = 'tile-body video-mode';
    body.innerHTML = `<iframe src="${embed}" allow="autoplay;encrypted-media" allowfullscreen></iframe>`;
    if (btn) btn.textContent = 'Aa';
  }
}

async function copyPlaylist(btn) {
  // Use cached stream data so clipboard.writeText runs immediately
  // (no async gap that would invalidate the user gesture)
  const list = Object.values(streams);
  const playlist = list.map(s => ({ url: s.url, name: s.name, type: s.type }));
  const text = JSON.stringify(playlist, null, 2);
  try {
    await navigator.clipboard.writeText(text);
  } catch (e) {
    // Fallback: hidden textarea + execCommand
    const ta = document.createElement('textarea');
    ta.value = text;
    ta.style.position = 'fixed';
    ta.style.opacity = '0';
    document.body.appendChild(ta);
    ta.select();
    document.execCommand('copy');
    document.body.removeChild(ta);
  }
  flash(btn);
}

async function pastePlaylist(btn) {
  const errEl = document.getElementById('error');
  errEl.textContent = '';
  let playlist;
  try {
    const text = await navigator.clipboard.readText();
    playlist = JSON.parse(text);
  } catch (e) {
    errEl.textContent = 'Clipboard does not contain a valid playlist';
    return;
  }
  if (!Array.isArray(playlist) || !playlist.length) {
    errEl.textContent = 'Clipboard does not contain a valid playlist';
    return;
  }
  for (const entry of playlist) {
    if (!entry.url) continue;
    try {
      await fetch(`${API}/streams`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ url: entry.url, name: entry.name || undefined, type: entry.type || undefined }),
      });
    } catch (e) {}
  }
  flash(btn);
  poll();
}

function flash(el) {
  el.classList.add('flash');
  setTimeout(() => el.classList.remove('flash'), 800);
}

// Click a timestamp → jump to that point in the embedded video
document.getElementById('grid').addEventListener('click', e => {
  const el = e.target.closest('.seg-time');
  if (!el || el.dataset.t == null) return;
  const tile = el.closest('.tile');
  if (!tile) return;
  seekVideo(tile.id.replace('tile-', ''), parseFloat(el.dataset.t));
});

// Poll every 2s
poll();
setInterval(poll, 2000);
</script>
</body>
</html>
